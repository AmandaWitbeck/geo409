<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8 />
    <title>ASW Module 12 Lab Practice Template</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>

    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: whitesmoke;
            font-family: Lato, sans-serif;
            color: #0D0000;
        }
        header {
            padding: 6px 10%;
        }
        h1 {
            display: inline-block;
            margin-right: 20px;
            color: #001323;
        }
        h2 {
            display: inline-block;
            color: #001323;
        }
        #map {
            width: 80%;
            height: 540px;
            margin: 10px auto;
        }
        footer {
            padding: 6px 10%;
            width: 80%;
        }
        p {
            font-size: 1em;
            color: #001323;
        }
        /* Additional style rules go here! */
        
        .popup {
            background: green; 
            color: green;
        }
    </style>
</head>

<body>
    <header>
        <h1>Map Title</h1>
        <h2>Map Subtitle</h2>
    </header>

    <div id='map'></div>

    <footer>
        <p>Map authored by Amanda Witbeck</p>
        <p>Additional information about the data and map goes here.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis urna magna, maximus nec laoreet sit amet, dictum ultricies nibh. Ut id auctor lacus. Nam a dolor et justo luctus luctus. Duis a elit eget risus dictum vehicula id eu elit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed sed enim nisl. Vestibulum commodo imperdiet lacus, sed facilisis erat placerat sit amet. Nulla consequat malesuada neque eget aliquet. Integer non convallis nisl, gravida ultrices ex. Fusce nec vestibulum elit. Sed elementum lectus ipsum, vulputate elementum ex laoreet a. Aenean eu ex varius, varius felis vitae, efficitur nulla. Quisque pretium laoreet ante, in sodales dui vehicula at. Mauris eu sem sapien.
        </p>
    </footer>
    <script src="power-plants.js"></script>
    <script>
        var options = {
            center: [38.0608, -97.9297],
            zoom: 3
        }
        var map = L.map('map', options);
        
        var tiles = L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
	       attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
	       subdomains: 'abcd',
	       minZoom: 0,
	       maxZoom: 18
});
        map.addLayer(tiles);
        
        // Begin writing your practice code here
        
//      So, instead, we recognize where the redundant code is and think of ways to loop through it.

The trick to doing this is to recognize where the values will be different for each one. So, for this example, we see this part remains the same for each:

    var hydroLayer = L.geoJson(plants, {
        pointToLayer: function(feature,latlng) {
            return L.circleMarker(latlng, commonStyles);
        },
Within the filter option, only the name of the fuel source will change, so in this case we're starting to think about substituting the hard-coded "Hydro" with a variable whose value will change as we loop through the entire strucutre:

    filter: function(feature) {
        if(feature.properties.fuel_source[<variableName>]) {
            return feature;
        }
    },
Finally, we see the hexidecimal color values for each has been hard-coded, so we'll want to swap those out with variables, as well as the fuel source we're using to pass a value to the getRadius() function.

        style: function(feature) {
            return {
                color: <variableName>,
                fillColor: <variableName>,
                radius: getRadius(feature.properties.fuel_source[<variableName>])
            }
        }
    }).addTo(map);
Okay, so we know that instead of repeating that same structure over and over again, we want to loop through it, substituting values for variable names upon each iteration. This is really similar to the simple for loops we've been using.

First, we'll create a JS object to hold the information we want to insert within the code. So for this example, we'll use our anticipated variable name for each Leaflet GeoJson layer as the property name, and then an object of the associated information for each layer. Eventually we'd include all 13 power types but to keep things simple we'll just show it for two.

    var layerInfo = {
        hydroLayer: {source:"Hydro", color:'#1f78b4'}, 
        windLayer: {source:"Wind", color:'#a6cee3'}
    }
We're going to loop through this object called layerInfo but before we do (and this is a bit tricky to get your head around) we'll create an empty object var geoJsonLayers = {} to hold the variable names for each Leaflet GeoJson layer we'll be creating.

    var layerInfo = {
        hydroLayer: {source:"Hydro", color:'#1f78b4'}, 
        windLayer: {source:"Wind", color:'#a6cee3'}
    }

    var geoJsonLayers = {};
Now we're ready to construct our looping structure. Because we're looping through a JS object layerInfo, and not an Array, we'll be using the for(var name in object) looping structure. You'll want to console.log(layer, layerInfo[layer]) within this loop to understand how it is accessing the object property names and values. Essentially, with each iteration here, layer will be the property name (i.e., "hydroLayer", "windLayer") and layerInfo[layer] will be accessing the associated Array (i.e., source:"Hydro", color:'#1f78b4')

The following code then achieves the same thing as repeating the structure to create the GeoJson layers:

    for(var layer in layerInfo) {     
        geoJsonLayers[layer] = L.geoJson(plants, {
            pointToLayer: function(feature,latlng) {
                return L.circleMarker(latlng, commonStyles);
            },
            filter: function(feature) {
                if(feature.properties.fuel_source[layerInfo[layer].source]) {
                    return feature;
                }
            },
            style: function(feature) {
                return {
                    color: layerInfo[layer].color,
                    fillColor: layerInfo[layer].color,
                    radius: getRadius(feature.properties.fuel_source[layerInfo[layer].source])
                } 
            } 
        }).addTo(map);        
     }
Furthermore, we've dynamically created variable names for each GeoJson layer and stored them as property names with the geoJsonLayers object with the geoJsonLayers[layer] = ... statement. Therefore, we can still access those layers (and add them to our Leaflet layer control by writing geoJsonLayers.hydroLayer etc.

The full solution then looks like this:

        var layerInfo = {
            hydroLayer: {source:"Hydro", color:'#1f78b4'}, 
            windLayer: {source:"Wind", color:'#a6cee3'}
        }
        var geoJsonLayers = {};

        for(var layer in layerInfo) {     
            geoJsonLayers[layer] = L.geoJson(plants, {
                pointToLayer: function(feature,latlng) {
                    return L.circleMarker(latlng, commonStyles);
                },
                filter: function(feature) {
                    if(feature.properties.fuel_source[layerInfo[layer].source]) {
                        return feature;
                    }
                },
                style: function(feature) {
                    return {
                        color: layerInfo[layer].color,
                        fillColor: layerInfo[layer].color,
                        radius: getRadius(feature.properties.fuel_source[layerInfo[layer].source])
                    } 
                } 
            }).addTo(map);        
         }

        function getRadius(val) {
            var radius = Math.sqrt(val/Math.PI);
            return radius * .8;   
        }

        var sourcesLabels = {
            "Hydro": geoJsonLayers.hydroLayer,
            "Wind": geoJsonLayers.windLayer
        }

        L.control.layers(null, sourcesLabels, { collapsed:false }).addTo(map);
Again, perhaps not immediately evident when only creating two layers, but certainly for many more the payoff in the cleanliness and maintainability of the code will be evident. A similar process could then be used to reduce the redundancy of repeating this code (i.e. how would we swap hydroLayer with each layer variable name?):

    map.on('click', function(e) {
        hydroLayer.eachLayer(function(layer) {
            var distance = e.latlng.distanceTo(layer.getLatLng())/1000;

            if(distance > 500) {
                layer.setStyle({
                    stroke: false,
                    fill: false
                });  
            } else {
               layer.setStyle({
                    stroke: true,
                    fill: true  
               });  
               layer.bindPopup("I am <b>"+distance.toLocaleString()+ 
                               "km</b><br> from the click point.");
            } 
        });
    });
    </script>
    
</body>

</html>